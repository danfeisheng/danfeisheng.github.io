---
layout: post
title: "读《高可用可伸缩微服务架构》感"
date: "2019-06-24 17:26"
author: "Danfei"
---
2019-06-24 17:26

读《高可用可伸缩微服务架构》感

维基百科对软件架构的定义：
	
	软件架构是有关软件整体结果与组件的抽象描述，用户指导大型软件系统各个方面的设计。软件架构师定义和设计软件的模块化，模块之间的交互，用户界面风格，
对外接口方法，创新的设计特性，以及高层事物的对象操作，逻辑和流程。软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件
之间的连接则明确和相对细致地描述组件之间的通信。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或对象。在面向对象领域中，组件之间的连接
通常用接口来实现。

	McGovern认为：软件架构或系统由组成系统的结构的互相作用和软件结构的重要设计决定组成。设计决定应成功实现所期望支持的质量。设计决定为系统开发，
支持，和维护提供概念上的基础。	

在《系统和软件工程-架构描述（Systems and software engineering-Architecture description）》中定义：

	1. 架构过程：在系统整个生命周期中构思，定义，表达，记录，交流，验证和实现，维护和改进架构的过程，也就是设计过程
	2. 架构：一个系统体现在其环境中的元素，关系的基本概念或属性，以及其设计和进化的原则
	3. 架构描述：表达一个架构的工作产出物（通常指的是各种架构图和设计文档）
	4. 架构视图：通过系统的某些关注点的视角，表达一个系统的工作产出物（例如部署视图，开发视图等）
	5. 系统：包含一个或多个进程，硬件，软件，工具与可以满足需求的人的集合
	6. 环境：决定开发，操作，策略和其他影响系统的设置和条件。
	
总结：软件架构是一个用户指导系统实现的草图。这个草图越详细，对系统实现的指导意义就越重要，且贯穿于软件的整个生命周期。在建筑领域，大楼尚未建造前，
就已经存在于建筑师的脑海里。同样地，开始编写第一行代码之前，系统就已经存在于软件架构师的心里。那么怎样把架构草图表达出来呢？我们一般都是采用架构图
和设计文档的形式。如果我们进一步追问，使用哪些方面的架构图和设计文档就能把架构草图表达清楚呢？草图里包含哪些具体的要素和对象呢？围绕着不同的具体操作
手段，就产生了不同的架构方法论。

一个典型的软件生命周期：产品立项->产品计划->场景->功能需求->技术选型->项目计划->研发->测试->发布版本->新增功能->修复bug->实施->发布前版本->多版本并行
->产品下线，主要分为设计期（包括立项，计划，技术选型与方案等），实现期间（包括开发，测试，发布，实施等），运行期（包括维护，修复bug，新增功能，
多版本维护等）。

设计期，需求导向，架构先行，架构设计工作是重中之重，其中包括
	
	系统拆分，如何把系统拆解为不同的子系统，模块，业务单元。
	技术选型，使用什么样的基础技术框架或脚手架
	技术验证，确定核心技术难点如何解决，检验能否满足期望指标
	接口规范，系统内部的不同部分以何种形式确定接口契约和数据通信方式
	集成方式，系统与外部其他业务系统如何进行集成
	技术规范，如何规范开发，测试部署和运维的技术标准性
	部署方案，系统如何进行物理部署，及其，配置，网络等要求
	运维方案，系统如何进行技术性运维，如何实现日常监控，预警报警
	......
	
实现期的主要任务是大量软件工程师根据设计期的设计进行编码。大量的技术人员，大家背景不同，知识储备不同，编程水平和习惯不同，努力程度不同。
**如何让所有工程师既能按数量保障项目进度，又能按质量保障软件品质呢？秘诀就在月：技术标准的精确统一，系统部件的良好拆分**，
此外最好有适合于此类项目的脚手架。系统部件的良好拆分，保障了任务可以拆散程一个个小的单元，分发给不同的开发者，技术标准的精确统一，
可以实现不同个体产出物最大程度的一致性。

这个时期因为业务调整或技术问题，可能会对架构设计的一些细节进行小范围调整，以适应实际项目的建设需求。在这个过程中，同时需要根据实际变化，对现有的
设计文档进行同步调整，以便精确地描述系统的状态及变化。

架构以文档和代码呈现

**文档是设计的载体，代码是系统功能实现的载体**

一般说的架构包括架构的设计过程，设计的产出物，可以是各类设计文档，设计图，也可以是一些技术验证代码，Demo等。文档的目的再约准确记录我们的思维产物，
在软件尚未实现时，作为指导蓝图，尽量精确地描述清楚软件。在软件的实现过程中，可能随着研究深入，根据具体情况对文档做出局部的调整和修改。在软件已经
实现以后，部署运行的软件实力和代码只能说明软件目前是什么状态，却无法告诉我们这个软件系统是如何从开始设计，慢慢变成现在看到的样子的，这个思维的过程
和中间做出的很多决策信息丢失了。一个软件系统的长期稳定发展，必然需要一个可靠的，随着软件本身的维护不断同步更新的文档作为每次变更的出发点。这样我们
可以沿着架构相关的文档逆流而上，了解这个软件系统从整体到具体的设计思路。

**那么怎样才能写出好的代码呢？关键在于：检验，重构。** GoF的23个设计模式是在面向接口的编程环境中，处理一些常见问题的代码编写经验。
通过灵活运用这些模式，我们就可以在处理各种一般问题时进行抽象和总结，进而写出结构良好，可读性强，并且具有一些灵活性的代码。

对于存量旧系统的维护和改造，很多时候无法一次完成目标，可以考虑循序渐进，设定几个大的里程碑，逐步推进，最终实现比较理想的架构设计。比如对于遗留系统，
先搞清楚需求，然后采用“分布式服务化+灰度发布”的方法，先拆出来并重新时间搜索系统，再拆出来订单系统，最后产品系统。经过几个月的改造，代码减少一半，
性能提升了几十倍。并且培养了几个完全能掌握系统的核心研发人员。这个过程最大的启发是：循序渐进，终达目标。
**特别是在具体的设计实践中，思路和方法，比结论更重要。一个正确的结论在别处可以就是错的，但是思路和方法是可以复用的**

在性能优化方面，一般采用的第一步就是找瓶颈，把一个复杂的业务处理过程拆解成多个服务或方法及的调用步骤，手机每个步骤的处理时间，然后找到最慢的地方进行
优化。如果最慢的步骤还包含多个小步骤，那么可以进一步按这种方式处理。

系统拆分到什么粒度是追合适的？一般认为系统拆分后，每个模块或组件的粒度标准应该满足一个原则：高内聚，低耦合。
高内聚是指模块内的功能和逻辑是紧密联系在一起的，低耦合是指模块之间的关联性非常小。

拆分是把整体变成很多局部，再对局部分开对待和研究其性质。反过来，按照高内聚的思想，把一些紧密联系的功能聚合后，打包成一个可以整体复用的部分，这就是
组件，这个过程就是组件化，我们可以得到抽象复用部分，再组合出来很多业务组件。这样，在更大粒度上实现了功能的复用。

非功能性需求九维目标：高性能，可靠性，稳定性，可用性，安全性，灵活性，易用性， 可扩展性，可维护性。

结合软件系统在整个生命周期的特点，可以进一步区分不同的架构风格

* 简单单体模式 - 代码层面没有拆分，所有的业务逻辑都在一个项目（project）里打包成一个编译后的二进制文件，通过这个文件进行部署，并提供业务能力
* MVC模式 - 系统内每个模块的功能组件按照不同的职责划分为模型（Model），视图（View），控制器（Controller）等角色，并以此来组织研发实现工作
* 前后端分离模式 - 将前后端代码耦合的设计改为前端逻辑和后端逻辑独立编写实现的处理模式
* 组件模式 - 系统的每一个模块拆分为一个子项目（subproject），每个模块独立编译打包成一个组件，所有需要的组件在一起部署到同一个容器里

**对于分布式架构，我们根据设计期的架构思想和运行期的不同结构，可以分为：**
	* 面向服务架构（Service Oriented Architecture, SOA） - 以业务服务的角度和服务中线的方式（一般是WebService与ESB）考虑系统架构和企业IT治理
	* 分布式服务架构（Distributed Service Architecture, DSA） - 基于去中心化的分布式服务框架与技术，考虑系统架构和服务治理
	* 微服务架构（Micro Service Architecture, MSA) - 微服务架构可以看做面向服务架构和分布式服务架构的拓展，
	使用更细粒度的服务和一组设计准则来考虑大规模和负责系统架构设计
