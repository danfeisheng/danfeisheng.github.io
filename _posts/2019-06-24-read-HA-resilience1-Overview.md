---
layout: post
title: "读《高可用可伸缩微服务架构》感"
date: "2019-06-24 17:26"
author: "Danfei"
---
2019-06-24 17:26

读《高可用可伸缩微服务架构》感

第一章 微服务架构概述

维基百科对软件架构的定义：
	
	软件架构是有关软件整体结果与组件的抽象描述，用户指导大型软件系统各个方面的设计。软件架构师定义和设计软件的模块化，模块之间的交互，用户界面风格，
对外接口方法，创新的设计特性，以及高层事物的对象操作，逻辑和流程。软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件
之间的连接则明确和相对细致地描述组件之间的通信。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或对象。在面向对象领域中，组件之间的连接
通常用接口来实现。

	McGovern认为：软件架构或系统由组成系统的结构的互相作用和软件结构的重要设计决定组成。设计决定应成功实现所期望支持的质量。设计决定为系统开发，
支持，和维护提供概念上的基础。	

在《系统和软件工程-架构描述（Systems and software engineering-Architecture description）》中定义：

	1. 架构过程：在系统整个生命周期中构思，定义，表达，记录，交流，验证和实现，维护和改进架构的过程，也就是设计过程
	2. 架构：一个系统体现在其环境中的元素，关系的基本概念或属性，以及其设计和进化的原则
	3. 架构描述：表达一个架构的工作产出物（通常指的是各种架构图和设计文档）
	4. 架构视图：通过系统的某些关注点的视角，表达一个系统的工作产出物（例如部署视图，开发视图等）
	5. 系统：包含一个或多个进程，硬件，软件，工具与可以满足需求的人的集合
	6. 环境：决定开发，操作，策略和其他影响系统的设置和条件。
	
总结：软件架构是一个用户指导系统实现的草图。这个草图越详细，对系统实现的指导意义就越重要，且贯穿于软件的整个生命周期。在建筑领域，大楼尚未建造前，
就已经存在于建筑师的脑海里。同样地，开始编写第一行代码之前，系统就已经存在于软件架构师的心里。那么怎样把架构草图表达出来呢？我们一般都是采用架构图
和设计文档的形式。如果我们进一步追问，使用哪些方面的架构图和设计文档就能把架构草图表达清楚呢？草图里包含哪些具体的要素和对象呢？围绕着不同的具体操作
手段，就产生了不同的架构方法论。

一个典型的软件生命周期：产品立项->产品计划->场景->功能需求->技术选型->项目计划->研发->测试->发布版本->新增功能->修复bug->实施->发布前版本->多版本并行
->产品下线，主要分为设计期（包括立项，计划，技术选型与方案等），实现期间（包括开发，测试，发布，实施等），运行期（包括维护，修复bug，新增功能，
多版本维护等）。

设计期，需求导向，架构先行，架构设计工作是重中之重，其中包括
	
	系统拆分，如何把系统拆解为不同的子系统，模块，业务单元。
	技术选型，使用什么样的基础技术框架或脚手架
	技术验证，确定核心技术难点如何解决，检验能否满足期望指标
	接口规范，系统内部的不同部分以何种形式确定接口契约和数据通信方式
	集成方式，系统与外部其他业务系统如何进行集成
	技术规范，如何规范开发，测试部署和运维的技术标准性
	部署方案，系统如何进行物理部署，及其，配置，网络等要求
	运维方案，系统如何进行技术性运维，如何实现日常监控，预警报警
	......
	
实现期的主要任务是大量软件工程师根据设计期的设计进行编码。大量的技术人员，大家背景不同，知识储备不同，编程水平和习惯不同，努力程度不同。
**如何让所有工程师既能按数量保障项目进度，又能按质量保障软件品质呢？秘诀就在月：技术标准的精确统一，系统部件的良好拆分**，
此外最好有适合于此类项目的脚手架。系统部件的良好拆分，保障了任务可以拆散程一个个小的单元，分发给不同的开发者，技术标准的精确统一，
可以实现不同个体产出物最大程度的一致性。

这个时期因为业务调整或技术问题，可能会对架构设计的一些细节进行小范围调整，以适应实际项目的建设需求。在这个过程中，同时需要根据实际变化，对现有的
设计文档进行同步调整，以便精确地描述系统的状态及变化。

架构以文档和代码呈现

**文档是设计的载体，代码是系统功能实现的载体**

一般说的架构包括架构的设计过程，设计的产出物，可以是各类设计文档，设计图，也可以是一些技术验证代码，Demo等。文档的目的再约准确记录我们的思维产物，
在软件尚未实现时，作为指导蓝图，尽量精确地描述清楚软件。在软件的实现过程中，可能随着研究深入，根据具体情况对文档做出局部的调整和修改。在软件已经
实现以后，部署运行的软件实力和代码只能说明软件目前是什么状态，却无法告诉我们这个软件系统是如何从开始设计，慢慢变成现在看到的样子的，这个思维的过程
和中间做出的很多决策信息丢失了。一个软件系统的长期稳定发展，必然需要一个可靠的，随着软件本身的维护不断同步更新的文档作为每次变更的出发点。这样我们
可以沿着架构相关的文档逆流而上，了解这个软件系统从整体到具体的设计思路。

**那么怎样才能写出好的代码呢？关键在于：经验，重构。** GoF的23个设计模式是在面向接口的编程环境中，处理一些常见问题的代码编写经验。
通过灵活运用这些模式，我们就可以在处理各种一般问题时进行抽象和总结，进而写出结构良好，可读性强，并且具有一些灵活性的代码。

对于存量旧系统的维护和改造，很多时候无法一次完成目标，可以考虑循序渐进，设定几个大的里程碑，逐步推进，最终实现比较理想的架构设计。比如对于遗留系统，
先搞清楚需求，然后采用“分布式服务化+灰度发布”的方法，先拆出来并重新时间搜索系统，再拆出来订单系统，最后产品系统。经过几个月的改造，代码减少一半，
性能提升了几十倍。并且培养了几个完全能掌握系统的核心研发人员。这个过程最大的启发是：循序渐进，终达目标。
**特别是在具体的设计实践中，思路和方法，比结论更重要。一个正确的结论在别处可以就是错的，但是思路和方法是可以复用的**

在性能优化方面，一般采用的第一步就是找瓶颈，把一个复杂的业务处理过程拆解成多个服务或方法及的调用步骤，手机每个步骤的处理时间，然后找到最慢的地方进行
优化。如果最慢的步骤还包含多个小步骤，那么可以进一步按这种方式处理。

系统拆分到什么粒度是追合适的？一般认为系统拆分后，每个模块或组件的粒度标准应该满足一个原则：高内聚，低耦合。
高内聚是指模块内的功能和逻辑是紧密联系在一起的，低耦合是指模块之间的关联性非常小。

拆分是把整体变成很多局部，再对局部分开对待和研究其性质。反过来，按照高内聚的思想，把一些紧密联系的功能聚合后，打包成一个可以整体复用的部分，这就是
组件，这个过程就是组件化，我们可以得到抽象复用部分，再组合出来很多业务组件。这样，在更大粒度上实现了功能的复用。

非功能性需求九维目标：高性能，可靠性，稳定性，可用性，安全性，灵活性，易用性， 可扩展性，可维护性。

结合软件系统在整个生命周期的特点，可以进一步区分不同的架构风格

	- 简单单体模式 - 代码层面没有拆分，所有的业务逻辑都在一个项目（project）里打包成一个编译后的二进制文件，通过这个文件进行部署，并提供业务能力
	- MVC模式 - 系统内每个模块的功能组件按照不同的职责划分为模型（Model），视图（View），控制器（Controller）等角色，并以此来组织研发实现工作
	- 前后端分离模式 - 将前后端代码耦合的设计改为前端逻辑和后端逻辑独立编写实现的处理模式
	- 组件模式 - 系统的每一个模块拆分为一个子项目（subproject），每个模块独立编译打包成一个组件，所有需要的组件在一起部署到同一个容器里

**对于分布式架构，我们根据设计期的架构思想和运行期的不同结构，可以分为：**

	- 面向服务架构（Service Oriented Architecture, SOA） - 以业务服务的角度和服务中线的方式（一般是WebService与ESB）考虑系统架构和企业IT治理
	- 分布式服务架构（Distributed Service Architecture, DSA） - 基于去中心化的分布式服务框架与技术，考虑系统架构和服务治理
	- 微服务架构（Micro Service Architecture, MSA) - 微服务架构可以看做面向服务架构和分布式服务架构的拓展，使用更细粒度的服务和一组设计准则来考虑大规模和负责系统架构设计


面向服务架构（SOA）是一种建设企业IT生态系统的架构指导思想。SOA的关注点是服务，服务是最基本的业务功能单元，由平台中立性的接口契约来定义。通过将业务
系统服务化，可以将不同模块解耦，各种异构系统间可以轻松实现服务调用，消息交换和资源共享。

SOA的两大基石：RPC和MQ

SOA关注系统的服务化，不同系统服务间的互相通信就成为一个重要的话题，随着RPC和MQ技术的发展，这两种技术逐渐成为SOA的两大基石，也是分布式技术体系的重要基础设施。

RPC是一种通用性的系统通信手段，使得我们可以像调用本地方法一样调用远程系统的方法。

典型的RPC处理机制包括两部分
	
	* 通信协议，可以是基于TPC的，也可以是基于HTTP的
	* 数据格式，一般是一套序列化+反序列化机制
	
从调用方式来看，RPC有四种模式

	+ RR（Request-Response）模式，又叫请求响应模式，指每个调用都要有具体的返回结果信息
	+ Oneway模式，又叫单向调用模式，调用即返回，没有响应的消息
	+ Future模式，又叫异步模式，调用后返回一个Futrue对象，然后执行完获取返回结果信息
	+ Callback模式，又叫回调模式，处理请求完成后，将处理结果信息作为参数传递给回调函数进行处理
	
所以从本质上看，RPC一般对于客户端来说是一种同步的远程服务调用技术。与其对应的，一般来说，MQ恰恰是一种异步的通信技术

处理请求先作为一个消息发送到MQ（也叫做Message Broker），接着处理消息的系统从MQ获取消息并进行处理。这样就是实现了各个系统间的解耦，同时可以把失败策略，
重试等作为一个机制，对各个应用透明，直接在MQ与各个调用方的应用接口层面实现即可。

消息队列在各类架构设计中的作用，一般有以下几点：
	
	- 为系统增加通用性的异步处理能力
	- 降低系统间的耦合
	- 提升了系统的业务缓冲能力，即**削峰填谷**，经过MQ作为中间件的缓冲，如果业务量突然增大时可以先把处理请求缓冲到队列中，在根据业务消费处理能力逐个
	处理，保障了系统不会因为突然爆发的大量请求而过载瘫痪，影响系统可用性。
	- 增强了系统的扩展能力，通过消息队列处理业务，消费端的处理能力如果不够，可以随时多加几个消费者来处理，从而直接扩展系统的业务处理能力。
	- 提升系统间通信的可靠性，无论通信本身的可靠性上（请求相应机制，重试），还是业务意义上（处理顺序，事务，失败策略）的可靠性，都比RPC有所增强
	
微服务（MSA）

The microservice architectural style is an approach to developing a signle application as a suite of small services, each running in its own process 
and communicating with lightweight mechanisms, offten an HTTP resource API. The services are build around business capabilities and independently 
deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in 
different programming languages and use different data storage technologies.

抽象出几个关键点：
	- 由一些独立的服务共同组成应用系统
	- 每个服务单独部署，独立运行在自己的进程中
	- 每个服务都是独立的业务
	- 分布式管理

微服务划分所遵循的原则是**低耦合和高内聚**

低耦合：修改一个服务不需要同时修改另一个，每个微服务都可以单独修改和部署

高内聚：把相关事务放在一起，把不相关的排除出去，聚集在一起的事务做同一件事

**微服务与SOA的区别**

	- 微服务知识一种经过良好架构设计的SOA解决方案，是面向服务的交付方案
	- **微服务更趋向于以自知的方式产生价值**
	- **微服务与敏捷开发的思想高度结合在一起，服务的定义更加清晰，同时减少了企业ESB开发的复杂性**
	- 微服务是SOA思想的一种提炼
	- **SOA是中ESB，微服务是轻网关**
	
使用微服务面临由单体项目向微服务项目过渡的问题，采用微服务架构后意味着服务之间的调用链路会比以前延长很多，在调用链路上发生故障的概率也随之正大，
同时调用链路越长，性能越受影响。所以要大规模使用微服务不仅仅是从思想和业务上面进行合理划分，还需要诸多技术组件，以及高效的运维来协同合作。

	- 防止雪崩：当一个服务无法承受大请求压力的时候，是否会影响被依赖的其他服务？这时候可以考虑限流等措施。
	- 功能降级：当某个服务出现故障时，是否有容错手段让业务继续运行下去，而不影响整体应用。
	- 幂等：当用户多次下同一订单时，得到的结果永远是同一个。
	- 缓存：当请求量较大时，为避免对数据库造成较大压力，可以适当将一些变化较小，读取量较大的数据放入缓存
	- 超时：超时时间对于调用服务非常重要，超时时间设置太长可能会把整体系统拖慢，甚至如果被调用服务hang住，如果没有合理的超时时间，整个系统看起来也hang住了，
	并且阻塞的线程会一直占用系统资源直至耗尽，设置短了会造成调用服务未完成而返回，实际工作中需要根据业务场景分析，选择一个恰当的值
	- 熔断：请求下游的服务发生一定数量的失败后，熔断器打开，接下来的请求快速返回失败，过一段时间再检查下游服务是否恢复正常，重置熔断器
	- 服务隔离：当所调用的服务发生故障时，上游服务能够隔离故障以确保业务能够继续运行下去
	- 可伸缩：当并发量较大，原有服务集群无法满足现有业务场景时，可以采用扩容策略，当并发量较小时，服务集群可以采用缩容策略，以节省资源
	- 数据库拆分：每个独立部署的服务提供单独的数据库，降低了数据库耦合，也让不同微服务隔离的更彻底，同时也有利于不同数据库分别进行扩容和其他处理
	- 可扩展：系统经过良好的设计，可以随时以较小的改动代价增加新的功能或能力
	

	